use serde::{Deserialize, Serialize};

/// Records actual token usage from a backend response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenUsageRecord {
    /// Actual input tokens used by backend
    pub input_tokens: usize,
    /// Actual output tokens generated by backend
    pub output_tokens: usize,
    /// Total actual tokens (input + output)
    pub total_tokens: usize,
}

impl TokenUsageRecord {
    /// Create a record from backend token counts
    pub fn from_backend(input_tokens: usize, output_tokens: usize) -> Self {
        Self {
            input_tokens,
            output_tokens,
            total_tokens: input_tokens + output_tokens,
        }
    }
}

/// Accumulates actual token usage across a conversation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenAccountant {
    /// Total input tokens accumulated
    total_input_tokens: usize,
    /// Total output tokens accumulated
    total_output_tokens: usize,
    /// Total tokens accumulated
    total_tokens: usize,
    /// Number of API calls recorded
    call_count: usize,
}

impl TokenAccountant {
    pub fn new() -> Self {
        Self {
            total_input_tokens: 0,
            total_output_tokens: 0,
            total_tokens: 0,
            call_count: 0,
        }
    }

    /// Record actual token usage from backend response
    pub fn record_usage(&mut self, record: TokenUsageRecord) {
        self.total_input_tokens += record.input_tokens;
        self.total_output_tokens += record.output_tokens;
        self.total_tokens += record.total_tokens;
        self.call_count += 1;
    }

    /// Get total actual tokens across all records
    pub fn total_tokens(&self) -> usize {
        self.total_tokens
    }

    /// Get total input tokens
    pub fn total_input_tokens(&self) -> usize {
        self.total_input_tokens
    }

    /// Get total output tokens
    pub fn total_output_tokens(&self) -> usize {
        self.total_output_tokens
    }

    /// Get average tokens per API call
    pub fn average_tokens_per_call(&self) -> usize {
        if self.call_count == 0 {
            0
        } else {
            self.total_tokens / self.call_count
        }
    }

    /// Get statistics summary
    pub fn statistics(&self) -> TokenAccountantStats {
        TokenAccountantStats {
            total_input_tokens: self.total_input_tokens,
            total_output_tokens: self.total_output_tokens,
            total_tokens: self.total_tokens,
            average_tokens_per_call: self.average_tokens_per_call(),
            record_count: self.call_count,
        }
    }

    /// Clear all records
    pub fn reset(&mut self) {
        self.total_input_tokens = 0;
        self.total_output_tokens = 0;
        self.total_tokens = 0;
        self.call_count = 0;
    }
}

/// Summary of token accounting statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenAccountantStats {
    pub total_input_tokens: usize,
    pub total_output_tokens: usize,
    pub total_tokens: usize,
    pub average_tokens_per_call: usize,
    pub record_count: usize,
}

impl TokenAccountantStats {
    /// Get human-readable summary
    pub fn summary_string(&self) -> String {
        format!(
            "Token Usage: {} total ({} in, {} out) | Avg: {}/call | Records: {}",
            self.total_tokens,
            self.total_input_tokens,
            self.total_output_tokens,
            self.average_tokens_per_call,
            self.record_count
        )
    }
}

impl Default for TokenAccountant {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_token_usage_record_creation() {
        let record = TokenUsageRecord::from_backend(80, 20);
        assert_eq!(record.input_tokens, 80);
        assert_eq!(record.output_tokens, 20);
        assert_eq!(record.total_tokens, 100);
    }

    #[test]
    fn test_token_accountant_record_usage() {
        let mut accountant = TokenAccountant::new();
        accountant.record_usage(TokenUsageRecord::from_backend(90, 10));
        accountant.record_usage(TokenUsageRecord::from_backend(95, 5));

        assert_eq!(accountant.total_tokens(), 200);
        assert_eq!(accountant.total_input_tokens(), 185);
        assert_eq!(accountant.total_output_tokens(), 15);
    }

    #[test]
    fn test_average_tokens_per_call() {
        let mut accountant = TokenAccountant::new();
        accountant.record_usage(TokenUsageRecord::from_backend(100, 50));
        accountant.record_usage(TokenUsageRecord::from_backend(100, 50));

        assert_eq!(accountant.average_tokens_per_call(), 150);
    }

    #[test]
    fn test_statistics() {
        let mut accountant = TokenAccountant::new();
        accountant.record_usage(TokenUsageRecord::from_backend(80, 20));
        accountant.record_usage(TokenUsageRecord::from_backend(90, 10));

        let stats = accountant.statistics();
        assert_eq!(stats.total_tokens, 200);
        assert_eq!(stats.total_input_tokens, 170);
        assert_eq!(stats.total_output_tokens, 30);
        assert_eq!(stats.average_tokens_per_call, 100);
        assert_eq!(stats.record_count, 2);
    }

    #[test]
    fn test_reset() {
        let mut accountant = TokenAccountant::new();
        accountant.record_usage(TokenUsageRecord::from_backend(100, 10));
        assert_eq!(accountant.total_tokens(), 110);

        accountant.reset();
        assert_eq!(accountant.total_tokens(), 0);
        assert_eq!(accountant.statistics().record_count, 0);
    }

    #[test]
    fn test_summary_string() {
        let stats = TokenAccountantStats {
            total_input_tokens: 700,
            total_output_tokens: 250,
            total_tokens: 950,
            average_tokens_per_call: 95,
            record_count: 10,
        };

        let summary = stats.summary_string();
        assert!(summary.contains("950 total"));
        assert!(summary.contains("700 in"));
        assert!(summary.contains("250 out"));
        assert!(summary.contains("95/call"));
    }
}
